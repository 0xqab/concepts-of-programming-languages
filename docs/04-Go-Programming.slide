Functional Programming with Go
Concepts of Programming Languages
25 Oct 2018
Tags: go, programming, master

Johannes Weigend (QAware GmbH)
University of Applied Sciences Rosenheim
johannes.weigend@qaware.de
http://www.qaware.de
@johannesweigend

* What is Functional Programming?
- the combination of pure functions;
- avoiding shared state, mutable data, and side-effects;
- the prevalence of declarative approach rather than imperative approach.

* Functional Programming – Characteristics
The most prominent characteristics of functional programming are as follows

- Functional programming languages are designed on the concept of mathematical functions that use conditional expressions and recursion to perform computation.
- Functional programming supports higher-order functions and lazy evaluation features.
- Functional programming languages don’t support flow Controls like loop statements and conditional statements like If-Else and Switch Statements. They directly use the functions and functional calls.
- Like OOP, functional programming languages support popular concepts such as Abstraction, Encapsulation, Inheritance, and Polymorphism

* Functional programming languages are categorized into two groups
- *Pure* Functional Languages
These types of functional languages support only the functional paradigms and have no state. For example − Haskell.

- *Impure* Functional Languages
These types of functional languages support the functional paradigms and imperative style programming. For example − LISP.

* Functional programming offers the following advantages

- Bugs-Free Code

Functional programming does not support state, so there are no side-effect results and we can write error-free codes.

- Efficiency

Functional programs consist of independent units that can *run* *concurrently*. As a result, such programs are more efficient.

- Lazy Evaluation 

Functional programming supports *lazy* *evaluation* like Lazy Lists, Lazy Maps, etc.

- Distribution 
Functional programming supports distributed computing

* Functional Composition
Functions can be composed to new functions
    g(f(x)) -> (g ◦ f)(x) 

        // Functional Composition in Go
        f := func(x int) int { return x * x }
        
        g := func(x int) int { return x + 1 }

        // Functional Composition: (g◦f)(x)
        gf := func(x int) int { return g(f(x)) }

        fmt.Printf("%v\n", gf(2)) // --> 5

        // Generic Composition of two functions
        compose := func(g, f func(int) int) func(int) int {
            return func(x int) int {
                return g(f(x))
            }
        }
        square := func(x int) int { return x * x }
        fmt.Printf("%v\n", compose(square, f)(2)) // --> 16

* History: The Lambda Calculus
.image https://upload.wikimedia.org/wikipedia/en/thumb/4/4d/Knights_of_the_Lambda_Calculus.svg/316px-Knights_of_the_Lambda_Calculus.svg.png 200 200
- What is it?
- Why is it useful?
- Where did it came from?
.link https://www.youtube.com/watch?v=eis11j_iGMs Professor Graham Hutton explains the Lambda Calculus (Cool Stuff :-)

Hint: To understand this video you will watch it at least three times :-)

* Summary of the Introduction to Lambda Calculus
- Pure Functions have no internal state
- The Lambda Calculus is very different to the Turing Machine in this way
- The lambda calculus knows only three primitives: Variables (x,y,z), building functions λx.x, applying functions "(λx.x) 5" with values
- There are no datatypes (number, logical values) - values can be functions, No build in recursion!
- It can encode any computation (Church-Turing thesis)
- Lambda Calculus is present in most major programming languages

* Lambda Calculus in Go
.link https://play.golang.org/p/GFdS5UxVb6z

        // Lambda Calculus in Golang --> See Video Graham Hutton

        // Some sample functions - strings are only used for debugging purposes
        f := func(x int) string { return fmt.Sprintf("f(%v)=%v", x, x+10) }	
        g := func(y int) string { return fmt.Sprintf("g(%v)=%v", y, y+20) }

        // TRUE as function: λx.λy.x
        TRUE := func(x, y func(int) string) func(int) string { return x }

        // FALSE as function: λx.λy.y
        FALSE := func(x, y func(int) string) func(int) string { return y }

        fmt.Println(TRUE(f, g)(1))  // -> 11
        fmt.Println(FALSE(f, g)(1)) // -> 21

        // NOT TRUE
        fmt.Println(TRUE(FALSE(f, g), TRUE(f, g))(2)) // -> 22 

        // NOT FALSE
        fmt.Println(TRUE(TRUE(f, g), FALSE(f, g))(2)) // -> 12

* Lambda Calculus in Go -> NOT
        // NOT as function λb.b
        NOT := func(b func(f, g func(int) string) func(int) string) 
                    func(x, y func(int) string) func(int) string {
            return func(f, g func(int) string) func(int) string {
                return b(FALSE(f, g), TRUE(f, g))
            }
        }

        fmt.Println(NOT(TRUE)(f, g)(3))   // -> 23
        fmt.Println(NOT(FALSE)(f, g)(3))  // -> 13

* Famous Functional Languages inspired by the Lamda Calculus
- Haskell
.link https://www.youtube.com/watch?v=1jZ7j21g028
- ML
- Clojure
- F#
- Scala

* Palindrome Problem in Functional (pure) Languages

- Haskell
   is_palindrome x = x == reverse x

- Clojure
    (defn palindrome? [x]
        (= x (clojure.string/reverse x)))

* Palindrome Problem in Functional (impure) Languages

- F#
    let isPalindrome (x: string) =
        let arr = x.ToCharArray()
        arr = Array.rev arr

- Scala
    def isPalindrome[A](l: List[A]):Boolean = {
        l == l.reverse
    }
- Go
    func IsPalindrome3(x string) bool {
        return x == strings.Reverse(x)
    }

* Functions as First Class Citizens in Go
- Go supports functions as 1st Class Citizens: Clojures und Lambdas
- Functions can be assigned to variables
- Functions can be used as function parameters and return values (High Order Functions)
- Functions can be created inside functions
- The Go standard library uses functional constructs

* Samples from the Go Standard Library
- strings.map
    // Map returns a copy of the string s with all its characters modified
    // according to the mapping function. If mapping returns a negative value, the character is
    // dropped from the string with no replacement.
    func Map(mapping func(rune) rune, s string) string

- Usage
    s := "Hello, world!"
    s = strings.Map(func(r rune) rune {
        return r + 1
    }, s)
    fmt.Println(s) // --> Ifmmp-!xpsme"

* Go does not have an API similar to Java Streams
- It is possible to build such an API in Go
.code ../fp/streams/streams_test.go /array/,/lambda/

* Classic Word Count Sample
.code ../fp/streams/streams_test.go /wordcount/,/ENDWC OMIT/

* Functional Programming and Iterators
- How to write an iterator in Go?

- Parallel Execution
- Split Iterators and parallel execution



